{
  "cout": {
    "prefix": "oo",
    "body": ["cout << $1 << \"\\n\";"],
    "scope": "cpp"
  },
  "cout double": {
    "prefix": "doo",
    "body": ["cout << fixed << setprecision(10) << $1 << endl;"],
    "scope": "cpp"
  },
  "priority_queue_asc": {
    "prefix": "priority_queue_asc",
    "body": ["priority_queue<$1, V<$1>, greater<$1>> $2;"],
    "scope": "cpp",
    "description": "昇順に並べた先頭から取り出される"
  },
  "mod": {
    "prefix": "template_mod",
    "body": [
      "template <int MOD>",
      "class Fp {",
      " public:",
      "  long long val;",
      "  constexpr Fp(long long v = 0) noexcept : val(v % MOD) {",
      "    if (val < 0) val += MOD;",
      "  }",
      "  constexpr int getmod() { return MOD; }",
      "  constexpr Fp operator-() const noexcept { return val ? MOD - val : 0; }",
      "  constexpr Fp operator+(const Fp& r) const noexcept { return Fp(*this) += r; }",
      "  constexpr Fp operator-(const Fp& r) const noexcept { return Fp(*this) -= r; }",
      "  constexpr Fp operator*(const Fp& r) const noexcept { return Fp(*this) *= r; }",
      "  constexpr Fp operator/(const Fp& r) const noexcept { return Fp(*this) /= r; }",
      "  constexpr Fp& operator+=(const Fp& r) noexcept {",
      "    val += r.val;",
      "    if (val >= MOD) val -= MOD;",
      "    return *this;",
      "  }",
      "  constexpr Fp& operator-=(const Fp& r) noexcept {",
      "    val -= r.val;",
      "    if (val < 0) val += MOD;",
      "    return *this;",
      "  }",
      "  constexpr Fp& operator*=(const Fp& r) noexcept {",
      "    val = val * r.val % MOD;",
      "    return *this;",
      "  }",
      "  constexpr Fp& operator/=(const Fp& r) noexcept {",
      "    long long a = r.val, b = MOD, u = 1, v = 0;",
      "    while (b) {",
      "      long long t = a / b;",
      "      a -= t * b;",
      "      swap(a, b);",
      "      u -= t * v;",
      "      swap(u, v);",
      "    }",
      "    val = val * u % MOD;",
      "    if (val < 0) val += MOD;",
      "    return *this;",
      "  }",
      "  constexpr bool operator==(const Fp& r) const noexcept {",
      "    return this->val == r.val;",
      "  }",
      "  constexpr bool operator!=(const Fp& r) const noexcept {",
      "    return this->val != r.val;",
      "  }",
      "  friend constexpr ostream& operator<<(ostream& os, const Fp<MOD>& x) noexcept {",
      "    return os << x.val;",
      "  }",
      "  friend constexpr Fp<MOD> modpow(const Fp<MOD>& a, long long n) noexcept {",
      "    if (n == 0) return 1;",
      "    auto t = modpow(a, n / 2);",
      "    t = t * t;",
      "    if (n & 1) t = t * a;",
      "    return t;",
      "  }",
      "};",
      "",
      "// const ll MOD = 998244353;",
      "const ll MOD = 1000000007;",
      "using mint = Fp<MOD>;",
      "",
      "struct combination_table {",
      "  // i! % MOD M",
      "  V<ll> fact;",
      "  // (i!)^(-1) MOD M",
      "  V<ll> finv;",
      "  // i^(-1) MOD M",
      "  V<ll> inv;",
      "};",
      "",
      "combination_table ct;",
      "",
      "// ref: http://drken1215.hatenablog.com/entry/2018/06/08/210000",
      "void prepare_combination(ll max) {",
      "  V<ll> fact(max + 1);",
      "  V<ll> finv(max + 1);",
      "  V<ll> inv(max + 1);",
      "",
      "  fact[0] = 1;",
      "  fact[1] = 1;",
      "  finv[0] = 1;",
      "  finv[1] = 1;",
      "  inv[1] = 1;",
      "",
      "  for (ll i = 2; i <= max; i++) {",
      "    fact[i] = fact[i - 1] * i % MOD;",
      "    inv[i] = MOD - inv[MOD % i] * (MOD / i) %",
      "                       MOD;  // a^(-1) ≡ -(p % a)^(-1) * (p/a) MOD p",
      "    finv[i] = finv[i - 1] * inv[i] % MOD;",
      "  }",
      "",
      "  ct = {",
      "      fact,",
      "      finv,",
      "      inv,",
      "  };",
      "}",
      "",
      "mint c_m(ll n, ll k) {",
      "  if (n < k) return 0;",
      "  if (n < 0 || k < 0) return 0;",
      "  return mint(ct.fact[n]) * ct.finv[k] * ct.finv[n - k];",
      "}",
      "",
      "// 重複組合せ n 種類から k 個重複を許して取る通り",
      "mint h_m(ll n, ll k) { return c_m((n - 1) + k, k); }",
      "",
      "mint p_m(ll n, ll k) { return c_m(n, k) * ct.fact[k]; }",
      ""
    ],
    "scope": "cpp"
  },
  "z_algorithm": {
    "prefix": "z_algorithm",
    "body": [
      "// O(|S|)",
      "// res[i]: S と S[i:] が先頭から何文字一致しているか",
      "VL z_algorithm(const string &S) {",
      "  ll N = S.size();",
      "  VL res(N);",
      "  res[0] = N;",
      "  ll i = 1, j = 0;",
      "",
      "  while (i < N) {",
      "    while (i + j < N && S[j] == S[i + j]) ++j;",
      "    res[i] = j;",
      "",
      "    if (j == 0) {",
      "      ++i;",
      "      continue;",
      "    }",
      "",
      "    ll k = 1;",
      "    while (i + k < N && k + res[k] < j) res[i + k] = res[k], ++k;",
      "    i += k, j -= k;",
      "  }",
      "",
      "  return res;",
      "}",
      ""
    ],
    "description": "z_algorithm",
    "scope": "cpp"
  },

  "def_lazy_seg_tree": {
    "prefix": "template_lazy_seg_tree",
    "body": [
      "template <class Monoid, class Action>",
      "struct LazySegTree {",
      "  using FuncMonoid = function<Monoid(Monoid, Monoid)>;",
      "  using FuncAction = function<void(Monoid &, Action)>;",
      "  using FuncLazy = function<void(Action &, Action)>;",
      "  FuncMonoid FM;",
      "  FuncAction FA;",
      "  FuncLazy FL;",
      "  Monoid UNITY_MONOID;",
      "  Action UNITY_LAZY;",
      "  ll SIZE, HEIGHT;",
      "  vector<Monoid> dat;",
      "  vector<Action> lazy;",
      "",
      "  LazySegTree(ll n, const FuncMonoid fm, const FuncAction fa, const FuncLazy fl,",
      "              const Monoid &unity_monoid, const Action &unity_lazy)",
      "      : FM(fm),",
      "        FA(fa),",
      "        FL(fl),",
      "        UNITY_MONOID(unity_monoid),",
      "        UNITY_LAZY(unity_lazy) {",
      "    SIZE = 1;",
      "    HEIGHT = 0;",
      "    while (SIZE < n) SIZE <<= 1, ++HEIGHT;",
      "    dat.assign(SIZE * 2, UNITY_MONOID);",
      "    lazy.assign(SIZE * 2, UNITY_LAZY);",
      "  }",
      "",
      "  void init(ll n, const FuncMonoid fm, const FuncAction fa, const FuncLazy fl,",
      "            const Monoid &unity_monoid, const Action &unity_lazy) {",
      "    FM = fm;",
      "    FA = fa;",
      "    FL = fl;",
      "    UNITY_MONOID = unity_monoid;",
      "    UNITY_LAZY = unity_lazy;",
      "    SIZE = 1;",
      "    HEIGHT = 0;",
      "    while (SIZE < n) SIZE <<= 1, ++HEIGHT;",
      "    dat.assign(SIZE * 2, UNITY_MONOID);",
      "    lazy.assign(SIZE * 2, UNITY_LAZY);",
      "  }",
      "",
      "  void set(ll a, const Monoid &v) { dat[a + SIZE] = v; }",
      "  void build() {",
      "    for (ll k = SIZE - 1; k > 0; --k) dat[k] = FM(dat[k * 2], dat[k * 2 + 1]);",
      "  }",
      "",
      "  inline void evaluate(ll k) {",
      "    if (lazy[k] == UNITY_LAZY) return;",
      "    if (k < SIZE) FL(lazy[k * 2], lazy[k]), FL(lazy[k * 2 + 1], lazy[k]);",
      "    FA(dat[k], lazy[k]);",
      "    lazy[k] = UNITY_LAZY;",
      "  }",
      "",
      "  inline void update(ll a, ll b, const Action &v, ll k, ll l, ll r) {",
      "    evaluate(k);",
      "    if (a <= l && r <= b)",
      "      FL(lazy[k], v), evaluate(k);",
      "    else if (a < r && l < b) {",
      "      update(a, b, v, k * 2, l, (l + r) >> 1),",
      "          update(a, b, v, k * 2 + 1, (l + r) >> 1, r);",
      "      dat[k] = FM(dat[k * 2], dat[k * 2 + 1]);",
      "    }",
      "  }",
      "",
      "  /* [a, b) */",
      "  inline void update(ll a, ll b, const Action &v) {",
      "    update(a, b, v, 1, 0, SIZE);",
      "  }",
      "",
      "  inline Monoid get(ll a, ll b, ll k, ll l, ll r) {",
      "    evaluate(k);",
      "    if (a <= l && r <= b)",
      "      return dat[k];",
      "    else if (a < r && l < b)",
      "      return FM(get(a, b, k * 2, l, (l + r) >> 1),",
      "                get(a, b, k * 2 + 1, (l + r) >> 1, r));",
      "    else",
      "      return UNITY_MONOID;",
      "  }",
      "",
      "  /* [a, b) */",
      "  inline Monoid get(ll a, ll b) { return get(a, b, 1, 0, SIZE); }",
      "",
      "  inline Monoid operator[](ll a) { return get(a, a + 1); }",
      "};",
      ""
    ],
    "description": "template_lazy_seg_tree",
    "scope": "cpp"
  },
  "use_lazy_seg_tree_min": {
    "prefix": "use_lazy_seg_tree_min",
    "body": [
      "  auto fm = [](ll a, ll b) { return min(a, b); };",
      "  auto fa = [](ll &a, ll b) { a = min(a, b); };",
      "  auto fl = [](ll &a, ll b) { a = min(a, b); };",
      "  LazySegTree<ll, ll> st(N, fm, fa, fl, INF, INF);",
      "  // st.set() で初期配列を埋められる。その場合 st.build() をその後に呼ぶ"
    ],
    "description": "use_lazy_seg_tree_min",
    "scope": "cpp"
  },
  "recursive": {
    "prefix": "template_recursive",
    "body": [
      "template <typename F>",
      "class",
      "#if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)",
      "    [[nodiscard]]",
      "#elif defined(__GNUC__) && \\",
      "    (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 4)",
      "    __attribute__((warn_unused_result))",
      "#endif",
      "    FixPoint : private F {",
      " public:",
      "  explicit constexpr FixPoint(F && f) noexcept : F(std::forward<F>(f)) {}",
      "",
      "  template <typename... Args>",
      "  constexpr decltype(auto) operator()(Args&&... args) const",
      "#if !defined(__GNUC__) || defined(__clang__) || __GNUC__ >= 9",
      "      noexcept(noexcept(",
      "          F::operator()(std::declval<FixPoint>(), std::declval<Args>()...)))",
      "#endif",
      "  {",
      "    return F::operator()(*this, std::forward<Args>(args)...);",
      "  }",
      "};",
      "",
      "template <typename F>",
      "static inline constexpr decltype(auto) makeFixPoint(F&& f) noexcept {",
      "  return FixPoint<F>{std::forward<F>(f)};",
      "}",
      ""
    ],
    "description": "template_recursive",
    "scope": "cpp"
  },
  "def_rec": {
    "prefix": "def-rec",
    "body": [
      "auto ${1:dfs} = makeFixPoint([&](auto f, $2) -> $3 {",
      "  // f($2)",
      "  $0",
      "});",
      ""
    ],
    "description": "def-rec",
    "scope": "cpp"
  },
  "print_vector": {
    "prefix": "print-vector",
    "body": [
      "rep(i, $1.size()) {",
      "  if (i > 0) cout << \" \";",
      "  cout << $1[i];",
      "}",
      "cout << \"\\n\";"
    ],
    "description": "print_vec",
    "scope": "cpp"
  },
  "factorize": {
    "prefix": "template_factorize",
    "body": [
      "VPL factorize(ll n) {",
      "  VPL res;",
      "",
      "  for (ll i = 2; i * i <= n; i++) {",
      "    if (n % i != 0) continue;",
      "",
      "    auto r = PL(i, 0);",
      "",
      "    while (n % i == 0) {",
      "      n /= i;",
      "      r.second++;",
      "    }",
      "",
      "    res.push_back(r);",
      "  }",
      "",
      "  // sqrt(n) 以上の素因数は高々一つ",
      "  if (n != 1) res.emplace_back(n, 1);",
      "",
      "  return res;",
      "}",
      ""
    ],
    "description": "factorize",
    "scope": "cpp"
  },
  "template-lca": {
    "prefix": "template_lca",
    "body": [
      "struct LCA {",
      "  VVL parent;  // parent[d][v] := 2^d-th parent of v",
      "  VL depth;",
      "",
      "  LCA() {}",
      "  LCA(const VVL& edge_list, ll r = 0) { init(edge_list, r); }",
      "",
      "  void init(const VVL& edge_list, ll r = 0) {",
      "    ll V = edge_list.size();",
      "    ll h = 1;",
      "    while ((1 << h) < V) ++h;",
      "    parent.assign(h, VL(V, -1));",
      "    depth.assign(V, -1);",
      "    dfs(edge_list, r, -1, 0);",
      "    for (ll i = 0; i + 1 < (ll)parent.size(); ++i)",
      "      for (ll v = 0; v < V; ++v)",
      "        if (parent[i][v] != -1) parent[i + 1][v] = parent[i][parent[i][v]];",
      "  }",
      "",
      "  void dfs(const VVL& edge_list, ll v, ll p, ll d) {",
      "    parent[0][v] = p;",
      "    depth[v] = d;",
      "    for (auto e : edge_list[v])",
      "      if (e != p) dfs(edge_list, e, v, d + 1);",
      "  }",
      "",
      "  ll get(ll u, ll v) {",
      "    if (depth[u] > depth[v]) swap(u, v);",
      "    for (ll i = 0; i < (ll)parent.size(); ++i)",
      "      if ((depth[v] - depth[u]) & (1 << i)) v = parent[i][v];",
      "    if (u == v) return u;",
      "    for (ll i = (ll)parent.size() - 1; i >= 0; --i) {",
      "      if (parent[i][u] != parent[i][v]) {",
      "        u = parent[i][u];",
      "        v = parent[i][v];",
      "      }",
      "    }",
      "    return parent[0][u];",
      "  }",
      "};",
      ""
    ],
    "description": "template_lca",
    "scope": "cpp"
  }
}
